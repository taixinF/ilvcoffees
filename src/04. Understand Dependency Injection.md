### 33. Understand Dependency Injection【04 Dependency Injection】

**coffee.module.ts**

`providers`

```ts
import { CoffeesService } from "./coffees.service";

@Module({
  imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
  controllers: [CoffeesController],
  //providers 完整写法
  // providers: [{
  //   provide: CoffeesService,
  //   useClass: CoffeesService
  // }]
  providers: [CoffeesService], //这只是简化最常见用例
})
export class CoffeesModule {
}
```

_本章后 我们将 研究其他有用的方法来提供代替_

### 34. Control NestJS Module Encapsulation(封装)

> nest generate module coffee-rating

> nest generate service coffee-rating

_我们要使用到coffee.module.ts 中的模块 就去 coffee-rating module 中 导入_

**coffee-rating.module.ts**

```ts
import { Module } from '@nestjs/common';
import { CoffeeRatingService } from './coffee-rating.service';
import { CoffeesModule } from '../coffees/coffees.module';

@Module({
  imports: [CoffeesModule],
  providers: [CoffeeRatingService],
})
export class CoffeeRatingModule {
}
```

_切换到CoffeeRatingService，并使用基于构造函数的注入来添加_

**coffee-rating.service.ts**

```ts
import { Injectable } from '@nestjs/common';
import { CoffeesService } from "./coffees.service";

@Injectable()
export class CoffeeRatingService {
  constructor(private readonly coffeesService: CoffeesService) {
  }
}
```

_这"Nest无法解析CoffeeRatingService的依赖关系 报错_

_默认情况下 所有模块封装了他们的提供者 如果想在另一个模块使用 必须明确的将他们定义并导出_

_使他们成为该模块公共API的一部分_

**coffee.module.ts**

`@Module:exports`

```ts

@Module({
  imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
  controllers: [CoffeesController],
  providers: [CoffeesService],
  //+++  导出改service 成功引导后控制台将不会有错误
  exports: [CoffeesService],
})
export class CoffeesModule {
}
```

_这就是封装 这样我们coffeeRatingModule的任何地方都可以使用coffeesService_

_我们可以完全控制我们的模块和依赖它们的模块中的公共和私有可用的内容。_

### 35. Diving Into Custom Providers






