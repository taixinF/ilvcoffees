### 33. Understand Dependency Injection【04 Dependency Injection】

**coffee.module.ts**

`providers`

```ts
import { CoffeesService } from "./coffees.service";

@Module({
  imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
  controllers: [CoffeesController],
  //providers 完整写法
  // providers: [{
  //   provide: CoffeesService,
  //   useClass: CoffeesService
  // }]
  providers: [CoffeesService], //这只是简化最常见用例
})
export class CoffeesModule {
}
```

_本章后 我们将 研究其他有用的方法来提供代替_

### 34. Control NestJS Module Encapsulation(封装)

> nest generate module coffee-rating

> nest generate service coffee-rating

_我们要使用到coffee.module.ts 中的模块 就去 coffee-rating module 中 导入_

**coffee-rating.module.ts**

```ts
import { Module } from '@nestjs/common';
import { CoffeeRatingService } from './coffee-rating.service';
import { CoffeesModule } from '../coffees/coffees.module';

@Module({
  imports: [CoffeesModule],
  providers: [CoffeeRatingService],
})
export class CoffeeRatingModule {
}
```

_切换到CoffeeRatingService，并使用基于构造函数的注入来添加_

**coffee-rating.service.ts**

```ts
import { Injectable } from '@nestjs/common';
import { CoffeesService } from "./coffees.service";

@Injectable()
export class CoffeeRatingService {
  constructor(private readonly coffeesService: CoffeesService) {
  }
}
```

_这"Nest无法解析CoffeeRatingService的依赖关系 报错_

_默认情况下 所有模块封装了他们的提供者 如果想在另一个模块使用 必须明确的将他们定义并导出_

_使他们成为该模块公共API的一部分_

**coffee.module.ts**

`@Module:exports`

```ts

@Module({
  imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
  controllers: [CoffeesController],
  providers: [CoffeesService],
  //+++  导出改service 成功引导后控制台将不会有错误
  exports: [CoffeesService],
})
export class CoffeesModule {
}
```

_这就是封装 这样我们coffeeRatingModule的任何地方都可以使用coffeesService_

_我们可以完全控制我们的模块和依赖它们的模块中的公共和私有可用的内容。_

### 35. Diving Into Custom Providers

### 36. Value Based Providers

### 37. Subclassed Provider Tokens

_自定义注入providers_

`useValue`

**coffees.module.ts**

```ts
import { COFFEE_BRANDS } from "./coffees.constants";

@Module({
  imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
  controllers: [CoffeesController],
  providers: [CoffeesService, {
    provide: COFFEE_BRANDS,
    useValue: ['buddy brew', 'nescafe']
  }],
  exports: [CoffeesService],
})
export class CoffeesModule {
}
```

**coffees.service.ts**

```ts
import { Inject, Injectable, NotFoundException } from '@nestjs/common';
import { COFFEE_BRANDS } from './coffees.constants';

//...
@Injectable()
export class CoffeesService {
  constructor(
    //...
    @Inject(COFFEE_BRANDS) coffeeBrands: string[],
  ) {
    console.log(coffeeBrands);
  }

//...
}
```

### 38. Class ProviderS

_根据当前环境，我们需要Nest为每个配置服务提供不同的实现_

**coffees.module.ts**

```ts
import { COFFEE_BRANDS } from "./coffees.constants";

class ConfigService {
}

class DevelopmentConfigService {
}

class ProductionConfigService {
}

@Module({
  imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
  controllers: [CoffeesController],
  providers: [CoffeesService, {
    provide: ConfigService,
    useClass: process.env.NODE_ENV === 'development' ? DevelopmentConfigService : ProductionConfigService
  }, {
    provide: COFFEE_BRANDS,
    useValue: ['buddy brew', 'nescafe']
  }],
  exports: [CoffeesService],
})
export class CoffeesModule {
}
```

### 39. Factory Providers

`useFactory` 语法允许让我们动态创建提供者

`inject` 本身提供一个提供者数组---这些提供者被传递到我们的 useFactory 函数中，我们可以随心所欲地使用它们

**coffees.module.ts**

```ts
import { COFFEE_BRANDS } from "./coffees.constants";
import { Injectable } from "@nestjs/common";

@Injectable()
export class CoffeesBrandsFactory {
  create() {
    return ['buddy brew', 'nescafe']
  }
}

@Module({
  imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
  controllers: [CoffeesController],
  providers: [
    CoffeesService,
    CoffeesBrandsFactory,
    {
      provide: COFFEE_BRANDS,
      useValue: (brandsFactory: CoffeesBrandsFactory) => brandsFactory.create(),
      inject: [CoffeesBrandsFactory]
    }
  ],
  exports: [CoffeesService],
})
export class CoffeesModule {
}
```

_虽然以上Injectable是演示的伪代码_

_这里重要的是知道你可以在这里使用你的依赖项 为这个提供者做任何你想做的_


### 40. Leverage(利用) Async Providers

